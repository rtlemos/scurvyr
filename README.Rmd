---
title: "Context-dependent space filling curves"
author: "Ricardo T. Lemos"
date: "9/22/2018"
output: md_document
---
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Setting up...

```{r}
library(surfacecurve)
library(ggplot2)
library(Matrix)
verbose = FALSE
```

Let's start with a mock square dataset.

```{r}
r = 8
square = mapply(1:24, FUN = function(j) mapply(1:24, FUN = function(i) {
  sin((i-1)*pi/r) + cos((j-1)*pi/r) + 8 * sin((i-1)*pi/r) * cos((j-1)*pi/r)
}))
image(Matrix(square))
```

The algorithm draws a context-dependent path through the gridpoints so that it spends as much time as possible in each "bubble" before moving on to the next one.

```{r}
s = sfc(data = square, lat = nrow(square):1, lon = 1:ncol(square), verbose = verbose)
plotPath(s)
```

Let's replace one of the bubbles with NAs.

```{r}
squareNA = square
squareNA[9:16, 13:20] = NA
image(Matrix(squareNA))
```

We can see the impact of NAs on the path.

```{r}
sNA = sfc(data = squareNA, lat = nrow(square):1, lon = 1:ncol(square), verbose = verbose)
plotPath(sNA)
```

Not all datasets with NAs allow valid paths. It is better to pass a full dataset without NAs into
a function like `preprocess`. Here, for example, we fill with NAs most values above 0, except those
needed to make a valid path. Note that NAs come in 2x2 blocks that end in even row and column numbers.

```{r}
squareB = preprocess(data = square, thresh = 0, verbose = verbose)
image(Matrix(squareB))
```
```{r}
s = sfc(data = squareB, lat = nrow(square):1, lon = 1:ncol(square), verbose = verbose)
plotPath(s)
```

OK, enough mock data. Let us look at a 2 degree gridded global topography of the world. 

```{r}
cETOPO4 = getCoarseETOPO(4)
image(Matrix(cETOPO4$data))
```

We are only interested in bathymetry (depth < 0 m), though, so we use `preprocessBathymetry`.

```{r}
cETOPO4$data = preprocessBathymetry(cETOPO4$data, neritic = -1, verbose = verbose)
s4 = sfc(data = cETOPO4$data, lat = cETOPO4$lat, lon = cETOPO4$lon, verbose = verbose)
plotPath(s4)
```
This may take an hour: finally, we run the algorithm on the whole ETOPO30 bathymetry data.

```{r}
data = preprocessBathymetry(etopo30, neritic = -2000, verbose = verbose)
lat = seq(89.75, -89.75, by=-0.5)
lon = seq(-179.75, 179.75, by=0.5)
sEtopo = sfc(data = data, lat = lat, lon = lon, verbose = verbose)
plotPath(sEtopo)
```

